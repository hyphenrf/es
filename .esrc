# functions
############
#
# fn-empty:             returns whether a var is ()
# fn-%*:                convenience arithmetic functions
# fn-(car cdr ini fin): list ops
# fn-alias:             alias a cmd, taken from the es examples
# fn-switch:            implementation of the switch statement
#    usage: switch expr ( pattern { body }
#                         pattern { body } ...
#                         '*'     { default body } )
# [always-]with-bash:   for commands that don't behave well under es
# fn-edfn:              edfn fn cmd: applies cmd on the function text
#
############

fn empty var { ~ $#var 0 }

fn %% { bc <<<$^* }
fn %! { bc -l <<<$^* }

fn car xs { return $xs(1) }
fn cdr xs { return $xs(2 ...) }
fn ini xs { return $xs(1 ... `{%% $#xs - 1}) }
fn fin xs { return $xs($#xs) }

fn alias name cmd {
   if {~ $name $cmd(1)} {cmd =<= {%whatis $cmd(1)} $cmd(2 ...)}
   fn-$name = $cmd
}

fn switch match cases {
   let ((case body rest) = $cases)
    if { eval '~' $match $case }{
       $body
    }{ switch $match $rest }
}

fn with-bash cmd {
   local (SHELL =<= {let (fn-bash = ) %whatis bash}) $cmd
}

fn always-with-bash cmd {
  let (def =<= {%whatis $cmd})
    fn-$cmd = with-bash $def
}

fn edfn fname cmd {
   eval `{var fn-$fname | $cmd}
}



# env
######
#
# notes:
#  - flatten on PATH: if PATH is empty, flatten gets just one param
#                     and gets no `:'
#  - XDG_RUNTIME_DIR: car picks first non-empty arg of its arglist
#
#  fn-oref:   refereshes opam env, defined conditionally
#  fn-winenv: grab a var from the windows env
#
######

history  = ~/.es_history
NO_COLOR = 1
EDITOR   = vis

PATH =<= {%flatten : $PATH $HOME/.local/bin}
XDG_RUNTIME_DIR =<= {car $XDG_RUNTIME_DIR /var/run/user/$USER}
XDG_CONFIG_HOME=$HOME/.local/etc
XDG_CACHE_HOME=$HOME/.local/tmp
XDG_DATA_HOME=$HOME/.local/share

# opam
if {! empty `{which opam}} {
   fn oref {
      let (ifs=\n)
      for (i=`{opam env |sed '/^#/d;s/; export.*//'})
          eval $i
      return 0
   }
   oref
}

# windows env helper
fn winenv name {
   name =<= {%one $name}
   psh '$env:'$name |sed -E 's/\s+$//'
}



# aliases
##########

alias vi        vis
alias v         vis
#alias e         emacs
alias lc        ls -xF '--color=none'
alias ls        ls -1 '--color=none'
alias psh       powershell.exe
alias py        python3
alias pastebin  nc tcp.st 7777

fn g { grep -rn $1 . }

fn goarm args {
   local (GOARCH = arm) go build -ldflags '-s -w' $args
}

# hoogle
#
# queries hoogle with n queries. there are some problems with a straightforward
# implementation..
#
# queries can have spaces in them. they can have special chars. they must be
# urlencoded and quoted. we can invoke multiple curls, more normally inside a
# for-loop, but one curl with many urls + params each group of which separated
# by `-:'
# xargs is then crucial because it re-separates args from their one contiguous
# string repr. using eval here would lose quoting, and using the builtin split
# function would split spaces too eagerly (even inside the quoted query).
#
# haskell's least used symbol in typedefs perhaps is backtick. Therefore it's
# used as the column separator.
#
fn hoogle queries {
   xargs curl <<< <={ %flatten ' -: ' \
     '-sG https://hoogle.haskell.org -d count=10 -d mode=json -d format=text
      --data-urlencode hoogle='''$queries''''
   } |jq -r '.[]|.item+"`"+.package.name?+"`"+.module.name?' |column -ts'`'
}

fn pkgbuild queries {
   curl -s 'https://aur.archlinux.org/cgit/aur.git/plain/PKGBUILD?h='$queries
}

fn ipinfo ip {
   # empty $v ? abc$v = () : abc$^v = abc
   curl -w '\n' -s https://ipinfo.io/$^ip
}



# set cwd as home when launching from windows terminal
#
local (cwd = `{pwd}) {
   {~ $cwd /mnt/c/Users/`{winenv USERNAME}} && cd
}



# fun meta stuff
#################

# first we need to preserve the old %create (aka `>') behaviour
#
let (create = $fn-%create)
fn %create fd file cmd {
   # overriding the pipe '>' to something equivalent to `noclobber`
   if {access -w $file} {
      echo 'appending because file exists - use `clobber '$file'` to overwrite' >[1=2]
      %append $fd $file $cmd
   }{
      $create $fd $file $cmd
   }
}

fn clobber file {
   # ..then making an explicit clobbering function
   $&openfile w 1 $file true
}
