# functions
############
#
# fn-empty:             returns whether a var is ()
# fn-%*:                convenience arithmetic functions
# fn-(car cdr ini fin): list ops
# fn-map:               map f xs
# fn-filter:            filter p xs
# fn-switch:            implementation of the switch statement
#    usage: switch expr ( 'pattern' { body }
#                         'pattern' { body } ...
#                         '*'       { default body } )
# fn-alias:             alias a cmd, taken from the es examples
# [always-]with-bash:   for commands that don't behave well under es
# fn-export:            nop function, for compat with sh, useful in {opam env}
# 'fn-:':               nop function
# fn-edfn:              edfn fn cmd: applies cmd on the function text
#
############

fn empty {~ $* ()}

# TODO: bug: {%% 2 * 3} expands the globstar
fn %% { bc <<<$^* }
fn %! { bc -l <<<$^* }

fn car xs { return $xs(1) }
fn cdr xs { return $xs(2 ...) }
fn ini xs { return $xs(1 ... `{%% $#xs - 1}) }
fn fin xs { return $xs($#xs) }

fn map f xs {
   if { empty $xs }{
      return $xs
   }{
      return <={$f $xs(1)} <={map $f $xs(2 ...)}
   }
}

fn filter p xs {
   if { empty $xs }{
      return $xs
   }{
      return <={
        if { $p $xs(1) }{ result $xs(1) }{ result () }
      } <={filter $p $xs(2 ...)}
   }
}

fn switch match cases {
   let ((case body rest) = $cases)
    if { eval '~' $match $case }{
       $body
    }{ switch $match $rest }
}

fn alias name cmd {
   if {~ $name $cmd(1)} {cmd = <={
     catch @{ result $cmd(1) }{ %whatis $cmd(1) }
   } $cmd(2 ...)}
   fn-$name = $cmd
}

fn with-bash cmd {
   local (SHELL = <={let (fn-bash = ) %whatis bash}) $cmd
}

fn always-with-bash cmd {
  let (def = <={%whatis $cmd})
    fn-$cmd = with-bash $def
}

# TODO: bug: `export x` should be nop, `export x=3` should assign x
fn export {}
# TODO: bug: `:` should be in $fn-%eval*, so that `: x=3` is valid syntax
fn : {}

fn edfn fname cmd {
   eval `{var fn-$fname | $cmd}
}



# env
######
#
# notes:
#  - flatten on PATH: if PATH is empty, flatten gets just one param
#                     and gets no `:'
#  - XDG_RUNTIME_DIR: car picks first non-empty arg of its arglist
#
#  fn-oref:   refereshes opam env, defined conditionally
#  fn-winenv: grab a var from the windows env
#
######

history  = ~/.es_history
NO_COLOR = 1
EDITOR   = vis

# local paths are searched first
path = (
  $HOME/.local/bin
  $HOME/.cabal/bin
  $(path)
)

PATH = <={%flatten : $(path) .}
XDG_RUNTIME_DIR = <={car $XDG_RUNTIME_DIR /var/run/user/$USER}
XDG_CONFIG_HOME=$HOME/.local/etc
XDG_CACHE_HOME=$HOME/.local/tmp
XDG_DATA_HOME=$HOME/.local/share

# opam
if {! empty `{which opam}} {
   fn oref {
      let (options = $*; ifs = \n)
      for (i=`{opam env $options |sed '/^#/d;s/; export.*//'})
          eval $i
      return 0
   }
   oref
}

# windows env helper
fn winenv {
   psh '$env:'$1 |sed -E 's/\s+$//'
}



# aliases
##########

alias vi        vis
alias v         vis
alias lc        ls -xF '--color=none'
alias ls        ls -1 '--color=none'
alias psh       powershell.exe
alias py        python3
alias pastebin  socat - openssl:tcp.st:8777
alias ghc       ghc -no-keep-^(hi o)^-files
alias ghci      ghci -v0
alias abuild    abuild -c

alias gr        grep -rn

fn g { gr $* . }

fn goarm args {
   local (GOARCH = arm) go build -ldflags '-s -w' $args
}

# hoogle
#
# queries hoogle with n queries. there are some problems with a straightforward
# implementation..
#
# queries can have spaces in them. they can have special chars. they must be
# urlencoded and quoted. we can invoke multiple curls, more normally inside a
# for-loop, but one curl with many urls + params each group of which separated
# by `-:'
#
# to avoid parsing problems, we use \1 as a special separator as \0 has some
# problems of its own.
#
fn hoogle queries {
   let (
     params = <={%flatten '' (
       -G \1 'https://hoogle.haskell.org' \1
       -d \1 'count=10' \1 -d \1 'mode=json' \1 -d \1 'format=text' \1
       --data-urlencode \1 'hoogle='
     )}
   ) curl -sf <={%split \1 <={%flatten \1-:\1  $params ^ $queries}} \
   | jq -r '.[] |.item +"'\1'"+.package.name?+"'\1'"+.module.name?' \
   | column -ts \1
}

fn pkgbuild queries {
   curl -s 'https://aur.archlinux.org/cgit/aur.git/plain/PKGBUILD?h='$queries
}

fn ipinfo ip {
   # empty $v ? abc$v = () : abc$^v = abc
   curl -w '\n' -s https://ipinfo.io/$^ip
}

fn gccrun args {
   # let bindings that reference other bindings need nesting
   let (tmpdir = $TMPDIR /tmp)
   let (files = (`{find $tmpdir(1) -maxdepth 1 -name 'gccrun.*'}
                 `{mktemp -ut gccrun.XXXXXX}))
   {
     gcc -o $files(1) $args &&
     $files(1)
   }
}


# set cwd as home when launching from windows terminal
#
local (cwd = `{pwd}) {
   {~ $cwd /mnt/c/Users/`{winenv USERNAME}} && cd
}



# fun meta stuff
#################
#
# fn-%prompt: runs before the prompt is printed
# fn-rgbcol:  rgbcol string r g b returns ansi colored string
#
#################

# capture the $status of every command on evaluation
# and reset $status at the beginning of every shell session
#
fn %eval-noprint { status = <=$* }

let (loop = $fn-%interactive-loop)
 fn %interactive-loop { status = 0; $loop }

let (loop = $fn-%batch-loop)
 fn %batch-loop { status = 0; $loop }


# colorize any text by rgb values
#
fn rgbcol s r g b {
   # \1...\2 are delimiters understood by readline to indicate nonprintable
   # chars and make column calculations accurate for prompt etc..
   # they generalize bash's \[...\] builtin solution.
   return \1\033[38\;2\;^ $r ^\;^ $g ^\;^ $b ^m\2 \
        ^ $s \
        ^ \1\033[0m\2
}

# colorful prompt :)
#
# let (colors = <={ rgbcol '>'   0  56 168 } ^\
#               <={ rgbcol '>' 115  79 150 } ^\
#               <={ rgbcol '>' 215   2 112 } )
#
# prompt = $colors' ' '> ' '>>> '

prompt = $prompt $prompt(1)

# override prompt to take a different color on nonzero
#
let (
  # TODO: x = 1 returns 1; and is thus a "nonzero status"
  fn nonzero i {
     ! { empty $i || ~ $^i 0 } && # not empty or zero
     echo $i |grep -Eq '^[0-9]+$' # numeric only (es can return other things as status)
  }
  ogprom = $prompt
)
fn %prompt {
   if { nonzero $status } {
      prompt = <={ rgbcol $ogprom(3) 255 55 55 } $ogprom(2 ...)
   }{
      prompt = $ogprom
   }
}


# noclobber:
# first we need to preserve the old %create (aka `>') behaviour
#
#let (create = $fn-%create)
#fn %create fd file cmd {
#   # overriding the pipe '>' to something equivalent to `noclobber`
#   if {access -fw $file} {
#      echo >[1=2] \
#        'appending because file exists - use `clobber '$file'` to overwrite'
#      %append $fd $file $cmd
#   }{
#      $create $fd $file $cmd
#   }
#}

#fn clobber file {
#   # ..then making an explicit clobbering function
#   $&openfile w 1 $file true
#}


# source aliases generated by getexe.es
. ~/.es-win
